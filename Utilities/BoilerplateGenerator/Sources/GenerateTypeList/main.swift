
import Foundation

struct Output {
  var indentation = 0
  var lines: [String] = []
}
func <<(output: inout Output, next: String) {
  output.lines.append(contentsOf: next
    .components(separatedBy: "\n")
    .map { String(repeating: "  ", count: output.indentation) + $0 })
}
var output = Output()

output << """

/**
 This file is autogenerated by
 ```
 $ pushd Utilities/BoilerplateGenerator
 $ swift run TypeList
 $ popd
 ```
 */

/**
 `TypeList` provides a limited implementation of variadic generics for MLIR types. It enables the creation of a `Values` object which represents values of the types the represented by this `TypeList`. Under the hood, we just provide initializer for up to N types, similar to how the standard library does for Tuples.
 */
public struct TypeList<MLIR: MLIRConfiguration, Values, Members: MemberCollection, Builder>
where
  Members.Index == Int,
  Members.Element  == Value
{
  let types: [MLIR.`Type`]
  func values(from base: Members.Base, with Builder: Builder) -> Values {
    getValues(base, Builder)
  }
  private let getValues: (Members.Base, Builder) -> Values
}

extension TypeList where Builder == Void {
  func values(from base: Members.Base) -> Values {
    values(from: base, with: ())
  }
}

// MARK: - Trivial Initializers

public extension TypeList where Builder == Void, Values == Void {
  static var none: Self { Self() }
  init() {
    types = []
    getValues = { _, _ in () }
  }
}

public extension TypeList where Builder: _BuilderProtocol, Values == Builder {
  static var none: Self { Self() }
  init() {
    types = []
    getValues = { _, arg in arg }
  }
}

// MARK: - Dynamic Initializers

public extension TypeList where Builder == Void, Values == Members {
  init(_ types: [MLIR.`Type`])  {
    self.types = types
    self.getValues = { base, _ in base[keyPath: Members.keyPath] }
  }
}

public extension TypeList where Builder == _BuilderProtocol, Values == (Builder, Members) {
  init(_ types: [MLIR.`Type`])  {
    self.types = types
    self.getValues = { base, arg in (arg, base[keyPath: Members.keyPath]) }
  }
}

// MARK: - Variadic Initializers

public extension TypeList {
"""

output.indentation += 1
for typeCount in 1...10 {
  let types = 0..<typeCount
  output << """
    // \(typeCount) arbitrary types
    init(
    \(types.map { """
      _ t\($0): Type<MLIR>
    """ }.joined(separator: ",\n")))
    where
      Builder == Void,
      Values == (\(types.map { _ in "Value" }.joined(separator: ", ")))
    {
      types = [\(types.map { "t\($0)" }.joined(separator: ", "))]
      getValues = { base, _ in
        let values = base[keyPath: Members.keyPath]
        return (\(types.map { "values[\($0)]" }.joined(separator: ", ")))
      }
    }

    // \(typeCount) arbitrary types, with a builder
    init(
    \(types.map { """
      _ t\($0): Type<MLIR>
    """ }.joined(separator: ",\n")))
    where
      Builder: _BuilderProtocol,
      Values == (Builder, \(types.map { _ in "Value" }.joined(separator: ", ")))
    {
      types = [\(types.map { "t\($0)" }.joined(separator: ", "))]
      getValues = { base, Builder in
        let values = base[keyPath: Members.keyPath]
        return (Builder, \(types.map { "values[\($0)]" }.joined(separator: ", ")))
      }
    }

    // \(typeCount) specific types
    init<\(types.map { "T\($0): TypeClass" }.joined(separator: ", "))>(
    \(types.map { """
      _ t\($0): T\($0).Type
    """ }.joined(separator: ",\n")))
    where
      Builder == Void,
    \(types.map { """
      T\($0).MLIR == MLIR
    """ }.joined(separator: ",\n")),
      Values == (\(types.map { "TypedValue<T\($0)>" }.joined(separator: ",")))
    {
      types = [\(types.map { "t\($0).type" }.joined(separator: ", "))]
      getValues = { base, _ in
        let values = base[keyPath: Members.keyPath]
        return (\(types.map { "TypedValue(value: values[\($0)])" }.joined(separator: ", ")))
      }
    }

    // \(typeCount) specific types, with a builder
    init<\(types.map { "T\($0): TypeClass" }.joined(separator: ", "))>(
    \(types.map { """
      _ t\($0): T\($0).Type
    """ }.joined(separator: ",\n")))
    where
      Builder: _BuilderProtocol,
    \(types.map { """
      T\($0).MLIR == MLIR
    """ }.joined(separator: ",\n")),
      Values == (Builder, \(types.map { "TypedValue<T\($0)>" }.joined(separator: ",")))
    {
      types = [\(types.map { "t\($0).type" }.joined(separator: ", "))]
      getValues = { base, Builder in
        let values = base[keyPath: Members.keyPath]
        return (Builder, \(types.map { "TypedValue(value: values[\($0)])" }.joined(separator: ", ")))
      }
    }

    """
}
output.indentation -= 1

output << "}"
print(output.lines.joined(separator: "\n"))
